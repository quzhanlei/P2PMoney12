package cn.itcast.wh.p2pmoney12.ui;import android.content.Context;import android.text.TextUtils;import android.util.AttributeSet;import android.view.View;import android.view.ViewGroup;import android.widget.FrameLayout;import com.loopj.android.http.AsyncHttpClient;import com.loopj.android.http.AsyncHttpResponseHandler;import com.loopj.android.http.RequestParams;import cn.itcast.wh.p2pmoney12.R;import cn.itcast.wh.p2pmoney12.util.UIUtils;/** * Created by Administrator on 2015/12/14. * 自定义布局。 */public abstract class LoadingPage extends FrameLayout {    AsyncHttpClient client = new AsyncHttpClient();    private static final int PAGE_LOADING_STATE = 1;    private static final int PAGE_ERROR_STATE = 2;    private static final int PAGE_EMPTY_STATE = 3;    private static final int PAGE_SUCCESS_STATE = 4;    private int PAGE_CURRENT_STATE = 1;    private View loadingView;    private View errorView;    private View emptyView;    private View successView;    private LayoutParams lp;    //枚举对象!!    private ResultState resultState = null;    private Context mConext;    public LoadingPage(Context context) {        this(context, null);    }    public LoadingPage(Context context, AttributeSet attrs) {        this(context, attrs, 0);    }    public LoadingPage(Context context, AttributeSet attrs, int defStyleAttr) {        super(context, attrs, defStyleAttr);        // 记录上下文!!!        this.mConext = context;        init();    }// 初始化的时候,将加载中,错误,为空的界面放到FrameLayout中。    private void init() {        lp = new LayoutParams(ViewGroup.LayoutParams.MATCH_PARENT, ViewGroup.LayoutParams.MATCH_PARENT);        if (loadingView == null) {            loadingView = UIUtils.getXmlView(R.layout.page_loading);            addView(loadingView, lp);        }        if (errorView == null) {            errorView = UIUtils.getXmlView(R.layout.page_error);            addView(errorView, lp);        }        if (emptyView == null) {            emptyView = UIUtils.getXmlView(R.layout.page_empty);            addView(emptyView, lp);        }        //首先每个界面不一样,其次必须在服务器返回数据成功后才可以加载。        showSafePage();    }    // 安全的在主线程中操作ui。    private void showSafePage() {        UIUtils.runOnUIThread(new Runnable() {            @Override            public void run() {                showPage();            }        });    }    private void showPage() {        loadingView.setVisibility(PAGE_CURRENT_STATE == PAGE_LOADING_STATE ? View.VISIBLE : View.GONE);        errorView.setVisibility(PAGE_CURRENT_STATE == PAGE_ERROR_STATE ? View.VISIBLE : View.GONE);        emptyView.setVisibility(PAGE_CURRENT_STATE == PAGE_EMPTY_STATE ? View.VISIBLE : View.GONE);        if (successView == null) {            // 注意!!!!!! 不能用UIUtils.getXmlView();            successView = View.inflate(mConext, LayoutId(), null);            addView(successView, lp);        }        successView.setVisibility(PAGE_CURRENT_STATE == PAGE_SUCCESS_STATE ? View.VISIBLE : View.GONE);    }    public abstract int LayoutId();// 当fragment调用show方法,我就请求网络。    public void show() {//        归位到正在加载。        //状态归位        if (PAGE_CURRENT_STATE != PAGE_LOADING_STATE) {            PAGE_CURRENT_STATE = PAGE_LOADING_STATE;        }        //处理不需要发送请求来决定界面的情况 不需要发送请求 直接显示正确的界面。 根据url决定当前状态。        String url = url();        if (TextUtils.isEmpty(url)) {            resultState = ResultState.SUCCESS;            resultState.setContent("");            loadPage();        } else {// 将获取的数据都放入 枚举中。            client.get(url, params(), new AsyncHttpResponseHandler() {                // 服务器返回的数据!! 放入枚举中。                @Override                public void onSuccess(String content) {                    if (TextUtils.isEmpty(content)) {                        resultState = ResultState.EMPTY;                        resultState.setContent("");                    } else {                        resultState = ResultState.SUCCESS;                        resultState.setContent(content);                    }                    loadPage();                }                @Override                public void onFailure(Throwable error, String content) {                    resultState = ResultState.ERROR;                    resultState.setContent("");                    loadPage();                }            });        }    } // 判断服务器返回的数据,加载不同的界面。 并且如果是成功的界面,就把数据显示。让调用着实现。    private void loadPage() {        switch (resultState) {            case ERROR:                //当前状态设置为2，显示错误界面                PAGE_CURRENT_STATE = 2;                break;            case EMPTY:                //当前状态设置为3，显示空界面                PAGE_CURRENT_STATE = 3;                break;            case SUCCESS:                //当前状态设置为4，显示成功界面                PAGE_CURRENT_STATE = 4;                break;        }        // 判断到底显示哪个xml界面        showSafePage();        // 如果成功的话,处理数据并显示        if (PAGE_CURRENT_STATE == 4) {            OnSuccess(resultState, successView);        }    }    // 由子类去实现具体的数据解析和界面展示    protected abstract void OnSuccess(ResultState resultState, View successView);    // 有子类提供。    protected abstract RequestParams params();    // 由子类提供!!!    protected abstract String url();    public enum ResultState {        ERROR(2), EMPTY(3), SUCCESS(4);        //状态和内容        private int state;        private String content;        // 构造方法!!        ResultState(int state) {            this.state = state;        }        public int getState() {            return state;        }        public void setState(int state) {            this.state = state;        }        public String getContent() {            return content;        }        public void setContent(String content) {            this.content = content;        }    }}